@page "/upload"
@using Cataloguify.Client.Areas.Images
@inject IImagesService ImagesService
@inject ISnackbar Snackbar
@using MudBlazor
@using Blazor.Cropper
@inject IJSRuntime JSRuntime;

<div class="container">
    <div class="left-panel">
        <h1>Image Cropper</h1>
        <InputFile id="input1" OnChange="OnInputFileChange"></InputFile>
        <select @bind-value="enableProportion" @bind-value:event="onchange" class="select is-rounded my-2">
            <option value="true">Enable Proportion</option>
            <option value="false">Disable Proportion</option>
        </select>
        @if (bool.Parse(enableProportion))
        {
            <input type="number" @bind-value="proportion" placeholder="Proportion" class="input is-rounded" />
        }
        <br />
        <label class="checkbox px-2">
            Pure C# processing:
            <input type="checkbox" @bind="purecs" />
        </label>
    </div>
    <div class="right-panel">
        @if (!string.IsNullOrEmpty(imgUrl) && !parsing)
        {
            <div class="box">
                <h2 class="is-size-4 has-text-centered">Crop Result:</h2>
                <img src="@imgUrl" class="image is-centered" />
            </div>
        }
    </div>
</div>

@if (file != null)
{
    <div class="modal is-active">
        <div class="modal-background"></div>
        <div class="modal-card">
            <header class="modal-card-head">
                <p class="modal-card-title">Adjust your crop</p>
                <button class="delete" aria-label="close" @onclick="()=>file=null"></button>
            </header>
            <section class="modal-card-body">
                <Cropper MaxCropedHeight="500" MaxCropedWidth="500" @ref="cropper"
                        AspectRatio="proportion != 0 ? proportion : 1"
                        CropperHeight="400" RequireAspectRatio="@bool.Parse(enableProportion)"
                        InputId="input1" ImageFile="file" @bind-Ratio="ratio"
                        OffsetX="10" OffsetY="11" InitCropWidth="50" InitCropHeight="50"
                        AnimeGifEnable="true" PureCSharpProcessing="purecs"
                        IsCropLocked="isCropLocked" IsImageLocked="isImageLocked"
                        OnSizeChanged="SizeChanged">
                </Cropper>

            </section>
            <footer class="modal-card-foot">
                <button class="button is-success" @onclick="DoneCrop">Done</button>
                <button class="button is-info" @onclick="@DisplayInfo">Info</button>
            </footer>
        </div>
    </div>
}

@if (!string.IsNullOrEmpty(imgUrl) && !parsing)
{
    <div class="box">
        <h2 class="is-size-4 has-text-centered">Crop Result:</h2>
        <img src="@imgUrl" class="image is-centered" />
        <button class="button is-primary" @onclick="UploadImage">Upload Image</button> <!-- Upload button -->
    </div>
}


@code {
    Cropper cropper;
    IBrowserFile file;
    bool purecs = false;
    double width;
    double height;
    string imgUrl = "";
    bool parsing = false;
    string enableProportion = "false";
    double proportion = 1d;
    double ratio = 1;
    bool isCropLocked = false;
    bool isImageLocked = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
{
    if (firstRender)
    {
        await Task.Delay(100); 
        if (cropper == null)
        {
            Console.WriteLine("Cropper component is still not initialized. Attempting reinitialization.");
            await InvokeAsync(StateHasChanged); 
        }
        else
        {
            Console.WriteLine("Cropper component is now ready and initialized.");
        }
    }
}



    async Task OnInputFileChange(InputFileChangeEventArgs args)
    {
        if (args.File != null)
        {
            Console.WriteLine("File loaded successfully.");
            file = args.File;
            // Ensure UI updates, especially if UI elements depend on file being loaded
            StateHasChanged();
        }
        else
        {
            Console.WriteLine("Failed to load file.");
        }
    }

    async Task DoneCrop()
{
    if (cropper == null)
    {
        Console.WriteLine("Attempt to crop image without an initialized cropper component.");
        Snackbar.Add("Cropper is not ready. Please try again.", Severity.Error);
        return;
    }

    if (file == null)
    {
        Console.WriteLine("Attempt to crop image without a loaded file.");
        Snackbar.Add("No file loaded. Please upload a file.", Severity.Error);
        return;
    }

    try
    {
        var args = await cropper.GetCropedResult();
        if (args == null)
        {
            Console.WriteLine("Failed to retrieve cropped result.");
            Snackbar.Add("Cropping failed.", Severity.Error);
            return;
        }
        parsing = true;
        var base64string = await args.GetBase64Async();
        imgUrl = $"data:image/png;base64,{base64string}";
        parsing = false;
        Snackbar.Add("Image cropped successfully!", Severity.Success);
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Error during cropping: {ex.Message}");
        Snackbar.Add("Error during cropping: " + ex.Message, Severity.Error);
    }
    finally
    {
        file = null; // Ensure file is reset after processing
        StateHasChanged(); // Refresh UI to reflect changes
    }
}



    private void DisplayInfo()
    {
        if (cropper != null)
        {
            var cropInfo = cropper.GetCropInfo();
            Console.WriteLine($"Crop Info: {cropInfo}");
        }
        else
        {
            Console.WriteLine("Cropper info requested but cropper is not initialized.");
        }
    }


    void SizeChanged((double, double) t)
    {
        (width, height) = t;
    }

    void OnRatioChange(ChangeEventArgs args)
    {
        ratio = int.Parse(args.Value.ToString()) / 100.0;
    }

    async Task UploadImage()
    {
        if (string.IsNullOrEmpty(imgUrl))
        {
            Snackbar.Add("No image to upload.", Severity.Warning);
            return;
        }

        // Optional: Convert from base64 to a more suitable format if necessary
        // Normally, the API might require the image in a specific format or just the base64 string

        var response = await ImagesService.UploadImageAsync(imgUrl);
        if (response.IsSuccessStatusCode)
        {
            Snackbar.Add("Image uploaded successfully!", Severity.Success);
        }
        else
        {
            Snackbar.Add("Failed to upload image. Error: " + response.ErrorMessage, Severity.Error);
        }
    }


}


<style>
    @@import url("https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css");
    .container {
        display: flex;
        justify-content: space-between;
    }
    .left-panel, .right-panel {
        flex: 1;
    }
    .modal-card-body {
        padding: 20px;
    }
    .image {
        max-width: 100%;
        height: auto;
        display: block;
        margin: 0 auto;
    }
    .box {
        margin-top: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 3px rgba(10, 10, 10, 0.1);
    }
    .notification {
        margin-top: 20px;
    }
    .select, .input {
        margin-top: 10px;
    }
</style>
